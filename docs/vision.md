## MyCli 愿景：终端里的 Claude Code，给工程师看的实现

MyCli 的愿景不是「又一个能写代码的 AI 工具」，而是：

- **在终端里尽量还原 Claude Code 的使用体验**；
- 同时 **以工程视角，把背后的 C/S 架构、模块与数据流全部摊开**，方便你学习、改造、复用。

我们更看重的是：

- 你可以把 MyCli 当成一个「Claude Code Terminal 教学实现」；
- 你可以从中直接抄走架构和模块划分，接到自己的项目里；
- 你可以用它来实践「自然语言/对话层」与「Spec/引擎层」的解耦设计。

---

### 目标用户

- **软件开发工程师 / 架构师**
  - 想搞清楚 Claude Code 这一类工具在工程上的分层和职责拆分；
  - 希望有一份可以直接阅读、跑通、修改的参考实现；
  - 习惯用 C/S 架构、模块职责、领域模型来理解一个系统。

- **小团队 Tech Lead / 工程实践者**
  - 想在团队里引入「规范化的 AI 改码流程」，而不是零散的 prompt copy/paste；
  - 希望用 Spec + CLI + Git 的方式，让 LLM 参与日常开发但仍然可控、可审计；
  - 考虑后续将类似能力集成到 CI/CD 或自建平台里。

---

### 我们要复刻的“Claude Code 能力面”

我们重点对标的是 Claude Code 的这条主链路：

1. 理解当前代码仓库（项目结构、相关文件）；
2. 根据用户意图规划修改方案（plan）；
3. 生成候选补丁（patch）；
4. 通过 diff 呈现给用户审查；
5. 在用户确认后，安全地应用到本地，并与 Git 良好集成。

在 MyCli 中，这条链路被拆成：

- **Client 侧**：命令行入口 + 对话式 REPL；
- **Server 侧**：Project/Spec/Context/Plan/Patch/Git 等服务；
- **LLM 网关**：Prompt 构造 + 模型调用 + 结果解析。

所有这些都围绕一个明确的原则：

> 真正驱动引擎的是结构化的 Spec，而不是随意的一句 prompt。

自然语言对话只是 Spec 的一种输入方式，最终都会沉淀为内部的领域对象。

---

### 为什么要显式设计 C/S 架构和模块？

原因很工程：

- **方便你带着“角色”来阅读和开发**：
  - 写 CLI/REPL 的时候，不需要理解所有 LLM 细节，只要会调用 Server 接口；
  - 写 Core Engine 的时候，不用关心终端渲染和人机交互；
  - 写 Prompt/Model 的时候，可以把主要精力放在 Prompt 模板和结果解析上。
- **方便未来替换实现**：
  - 想把本地 Core Engine 换成一个远程 HTTP/gRPC 服务，只需要保持 Client ↔ Server 契约不变；
  - 想换模型厂商，只需要在 `ModelGateway` 下挂不同 Provider。
- **方便迁移到你的世界观**：
  - 如果你已经有一套服务化基础设施，可以直接把 Server 部分搬过去；
  - 如果你习惯 DDD/Hexagonal 等风格，可以用这些模块作为领域/应用层的起点。

---

### 不会做 / 暂时不做的事情

为了聚焦核心闭环，MVP 阶段**不会**做以下事情（后续版本可以讨论是否引入）：

- 不做复杂 UI，所有交互都在终端内完成；
- 不追求「长对话 Agent」能力，而是围绕一次次明确的改动任务；
- 不做跨仓库操作，只操作当前本地 Git 仓库；
- 不内置重型静态分析器，优先依赖 LLM + 轻量上下文选择；
- 不自动 push 到远端，仅在本地生成和提交变更（是否 push 由你自己决定）。

这些边界会在 `docs/roadmap.md` 中以阶段性约束的形式体现。

---

### 成功标准（对这个项目而言）

当我们说「MyCli v1.0 达标」时，希望意味着：

- 任何工程师只看 README 与架构文档，就能：
  - 画出自己的理解版架构图；
  - 说清楚 Client / Server / ModelGateway / GitAdapter 各自负责什么；
  - 按 roadmap 的阶段，从某个点切入实现或改造。
- 你可以把 MyCli 用在一个真实的小项目上：
  - 进入 `mycli chat`；
  - 说出一个不算太大的改动需求；
  - 看到 plan 和 diff，并敢于按下回车让它改。
- 即使你从来不用 MyCli，本仓库依然能作为：
  - 设计「对话层 ↔ Spec 层 ↔ 引擎层」的参考；
  - 设计「LLM + Git 工作流」的参考实现。

## MyCli 愿景：用 Spec Coding 学习 Claude Code

MyCli 的核心愿景是：**用一个足够清晰、足够小而完整的开源实现，复刻 Claude Code 的核心编辑循环，并以 Spec Coding 的方式暴露全部关键设计决策。**

与其说这是一个「能帮你写代码的 CLI 工具」，不如说它是一个：

- 用来**拆解 Claude Code 工作方式**的教学项目；
- 用来**实践 Spec 驱动开发（Spec Coding）**理念的实验场；
- 用来**观察「人类需求 → Spec → LLM → Patch → Git」完整闭环**的放大镜。

---

### 目标用户

- **个人开发者 / 学习者**
  - 想了解 Claude Code 这类「AI + IDE」是如何工作的；
  - 希望通过阅读完整实现 + 文档，而不是只看零散博客或视频；
  - 对「如何把自然语言需求结构化成 Spec，再交给 LLM」感兴趣。

- **小团队 / 工程实践者**
  - 想在自己的项目或 CI/CD 流水线中，尝试以更可控、更可审计的方式引入 LLM；
  - 希望有一套「从 Spec 到代码变更」的标准流程，可以内嵌到现有工程实践里；
  - 希望复用或改造 MyCli 的部分模块（如 Spec 解析、Context 收集、Patch 应用等）。

---

### 我们要复刻的是什么？

我们不打算一次性复刻 Claude Code 的所有能力，而是聚焦在它的**核心编辑循环**：

1. 理解当前代码仓库上下文；
2. 根据用户意图规划修改方案；
3. 生成候选补丁（patch）；
4. 通过 diff 呈现给用户审查；
5. 在用户确认后，安全地应用到本地，并与 Git 良好集成。

在 MyCli 里，这一循环有一个非常重要的前置步骤：**用户必须先写 Spec**。

---

### 为什么是 Spec Coding，而不是聊天式 Coding？

Claude Code 在 IDE 中可以支持非常自由的对话式使用方式（vibe coding），但在 MyCli 中我们刻意选择了 **Spec Coding** 作为核心入口，原因包括：

- **更可审计**：Spec 本身就是一份「需求说明文档」，可以被纳入代码评审流程；
- **更可复现**：同一份 Spec 在同一版本仓库上运行，期望得到相近（或可解释）的结果；
- **更利于学习**：通过 Spec 的字段设计，可以看清楚「Claude Code 需要哪些信息」；
- **更易自动化**：在 CI 或机器人流程中，更容易生成或修改 Spec，而不是模拟人类聊天。

因此，MyCli 的使用哲学是：

> 先写 Spec，把需求写清楚，剩下交给工具和模型。

---

### 不会做 / 暂时不做的事情

为了聚焦核心闭环，MVP 阶段**不会**做以下事情（后续版本可以讨论是否引入）：

- 不做「长对话式」多轮聊天界面；
- 不做复杂的 UI（只提供命令行体验）；
- 不做跨仓库操作；
- 不在本项目中内置过于复杂的静态分析器，而是优先依赖 LLM 对上下文的理解；
- 不自动 push 代码到远端，只在本地仓库内生成和提交变更。

这些约束会在 `docs/roadmap.md` 中体现为阶段性的边界条件。

---

### 成功标准（对这个项目而言）

当我们完成第一个可用版本时，希望能够达到以下状态：

- 任何一个开发者，只要按 README 操作，就能：
  - 为一个示例项目写一份 Spec；
  - 运行 `mycli plan` / `mycli apply` 或 `mycli run`；
  - 在看到清晰 diff 后，自信地接受这次自动化改动。
- 你可以通过阅读 docs 中的架构与模块说明，对 Claude Code 的核心原理有「结构化」的理解；
- 即使未来完全不用 MyCli，仍然可以把这里的 Spec/Context/Prompt/Patch 设计思想迁移到自己的系统中。

