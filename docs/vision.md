## MyCli 愿景：用 Spec Coding 学习 Claude Code

MyCli 的核心愿景是：**用一个足够清晰、足够小而完整的开源实现，复刻 Claude Code 的核心编辑循环，并以 Spec Coding 的方式暴露全部关键设计决策。**

与其说这是一个「能帮你写代码的 CLI 工具」，不如说它是一个：

- 用来**拆解 Claude Code 工作方式**的教学项目；
- 用来**实践 Spec 驱动开发（Spec Coding）**理念的实验场；
- 用来**观察「人类需求 → Spec → LLM → Patch → Git」完整闭环**的放大镜。

---

### 目标用户

- **个人开发者 / 学习者**
  - 想了解 Claude Code 这类「AI + IDE」是如何工作的；
  - 希望通过阅读完整实现 + 文档，而不是只看零散博客或视频；
  - 对「如何把自然语言需求结构化成 Spec，再交给 LLM」感兴趣。

- **小团队 / 工程实践者**
  - 想在自己的项目或 CI/CD 流水线中，尝试以更可控、更可审计的方式引入 LLM；
  - 希望有一套「从 Spec 到代码变更」的标准流程，可以内嵌到现有工程实践里；
  - 希望复用或改造 MyCli 的部分模块（如 Spec 解析、Context 收集、Patch 应用等）。

---

### 我们要复刻的是什么？

我们不打算一次性复刻 Claude Code 的所有能力，而是聚焦在它的**核心编辑循环**：

1. 理解当前代码仓库上下文；
2. 根据用户意图规划修改方案；
3. 生成候选补丁（patch）；
4. 通过 diff 呈现给用户审查；
5. 在用户确认后，安全地应用到本地，并与 Git 良好集成。

在 MyCli 里，这一循环有一个非常重要的前置步骤：**用户必须先写 Spec**。

---

### 为什么是 Spec Coding，而不是聊天式 Coding？

Claude Code 在 IDE 中可以支持非常自由的对话式使用方式（vibe coding），但在 MyCli 中我们刻意选择了 **Spec Coding** 作为核心入口，原因包括：

- **更可审计**：Spec 本身就是一份「需求说明文档」，可以被纳入代码评审流程；
- **更可复现**：同一份 Spec 在同一版本仓库上运行，期望得到相近（或可解释）的结果；
- **更利于学习**：通过 Spec 的字段设计，可以看清楚「Claude Code 需要哪些信息」；
- **更易自动化**：在 CI 或机器人流程中，更容易生成或修改 Spec，而不是模拟人类聊天。

因此，MyCli 的使用哲学是：

> 先写 Spec，把需求写清楚，剩下交给工具和模型。

---

### 不会做 / 暂时不做的事情

为了聚焦核心闭环，MVP 阶段**不会**做以下事情（后续版本可以讨论是否引入）：

- 不做「长对话式」多轮聊天界面；
- 不做复杂的 UI（只提供命令行体验）；
- 不做跨仓库操作；
- 不在本项目中内置过于复杂的静态分析器，而是优先依赖 LLM 对上下文的理解；
- 不自动 push 代码到远端，只在本地仓库内生成和提交变更。

这些约束会在 `docs/roadmap.md` 中体现为阶段性的边界条件。

---

### 成功标准（对这个项目而言）

当我们完成第一个可用版本时，希望能够达到以下状态：

- 任何一个开发者，只要按 README 操作，就能：
  - 为一个示例项目写一份 Spec；
  - 运行 `mycli plan` / `mycli apply` 或 `mycli run`；
  - 在看到清晰 diff 后，自信地接受这次自动化改动。
- 你可以通过阅读 docs 中的架构与模块说明，对 Claude Code 的核心原理有「结构化」的理解；
- 即使未来完全不用 MyCli，仍然可以把这里的 Spec/Context/Prompt/Patch 设计思想迁移到自己的系统中。

